## 前言

面试准备很重要，不准备，就是再厉害的人也可能会错失机会。

## 项目经历

+ 最得意的项目
+ 职位角色

## CSS

+ 盒模型
+ 水平垂直居中
+ FLEX
+ BFC https://juejin.im/post/59b73d5bf265da064618731d
+ GPU加速
+ 选择器优先级
+ CSS动画
+ 清除浮动
+ CSS性能优化
    - 内联首屏css
    - 异步加载非首屏css
    - css文件压缩
    - 去除无用css
    - 简化选择器层级
    - 减少使用耗性能的属性：box-shadow
    - 减少重排重绘
    - 不使用@import
    - 使用硬件加速：will-change

## JAVSCRIPT

+ 原型
+ 作用域
+ this
+ 变量提升
    - let/const声明会提升，只是进入TDZ，未初始化 https://www.jianshu.com/p/ebc51ce05416?utm_campaign=maleskine&utm_content=note&utm_medium=reader_share&utm_source=weibo
    - var声明和初始化都提升 
+ script引入方式
    - 默认是加载和执行阻塞渲染
    - defer是异步加载，且在COMContentLoaded事件之后顺序执行
    - async是异步加载，加载完成后立即执行
+ new执行过程
```
function _new(Fn, ...args) {
  let inst = {}
  inst.__proto__ = Fn.prototype
  let res = Fn.call(inst, ...args)
  return res instanceof Object ? res: inst
}
```
+ instanceof原理
```
function _instanceof(Fn ,inst) {
  let proto = inst.__proto__
  while(proto) {
    if(Fn.prototype === proto) {
      return true
    } 
    proto = proto.__proto__
  }
  return false
}
```
+ 箭头函数
+ call、apply、bind
```
Function.prototype._call = function(context, ...args) {
  context = context || window
  context._fn = this
  const res = context._fn(...args)
  delete context._fn
  return res
}
Function.prototype._apply = function(context, args) {
  context = context || window
  context._fn = this
  const res = context._fn(...args)
  delete context._fn
  return res
}
Function.prototype._bind = function(context, ...prevArgs) {
  context = context || window
  const fn = this
  return function F(...args) {
    const newArgs = [...prevArgs, ...args]
    // 构造函数调用
    if(this instanceof F) {
      return new fn(...newArgs)
    }
    return fn.call(context, ...newArgs)
  }
}
```
+ 防抖/节流 https://juejin.im/post/5ecbd9235188254348575bd9
+ ES6/ES7
    - Set/Map
    - 类
    - 扩展符
+ EventLoop 
    - 宏观任务
    - 微观任务
+ 内存泄漏
+ 内存回收
    - 新生代 将From(使用中)中的存活对象复制到To(空闲)中, From清空, 然后From和To互换
    - 老生代 标记清除算法    
+ async/await
```
// 借助Generator/Promise来实现async/await
function run (gen) {
  return new Promise((resolve, reject) => {
    const g = gen()

    function step (value) {
      let res
      try {
        res = g.next(value)
      }
      catch (e) {
        return reject(e)
      }

      if (res.done) {
        return res.value
      }

      Promise.resolve(res.value).then(
        (value) => {
          step(value)
        },
        (error) => {
          g.throw(error)
        },
      )
    }

    step()
  })
}

function* generator2 () {
  try {
    console.log(yield new Promise((resolve) => {
      setTimeout(() => {
        resolve(1)
      }, 1000)
    }))
    console.log(yield 2)   //2
    console.log(yield Promise.reject('error'))
  }
  catch (error) {
    console.log(error)
  }
}
run(generator2)
```
+ Promise
```
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'

class _Promise {
  constructor (executor) {
    this._status = PENDING
    this._value = undefined
    this._resolves = []
    this._rejects = []

    const resolve = (value) => {
      const run = () => {
        if (this._status !== PENDING) {
          return
        }

        this._status = FULFILLED
        this._value = value

        while (this._resolves.length) {
          const callback = this._resolves.shift()
          callback(value)
        }
      }
      setTimeout(run)
    }

    const reject = (value) => {
      const run = () => {
        if (this._status !== PENDING) {
          return
        }

        this._status = REJECTED
        this._value = value

        while (this._rejects.length) {
          const callback = this._rejects.unshift()
          callback(value)
        }
      }
      setTimeout(run)
    }

    // 初始化时, 立即执行executor
    executor(resolve, reject)
  }

  then (resolveFn, rejectFn) {
    if (typeof resolveFn !== 'function') {
      resolveFn = (value) => value
    }
    if (typeof rejectFn !== 'function') {
      rejectFn = (reason) => {
        throw new Error(reason instanceof Error ? reason.message : reason)
      }
    }

    return new _Promise((resolve, reject) => {
      const fulfilled = (val) => {
        try {
          const res = resolveFn(val)
          res instanceof _Promise ? res.then(resolve, reject) : resolve(res)
        }
        catch (e) {
          reject(e)
        }
      }

      const rejected = (err) => {
        try {
          let res = rejectFn(err)
          res instanceof _Promise ? res.then(resolve, reject) : resolve(res)
        }
        catch (e) {
          reject(e)
        }
      }

      switch (this._status) {
        case PENDING: {
          this._resolves.push(fulfilled)
          this._rejects.push(rejected)
          break
        }
        // 状态为FULFILLED/REJECTED时, 直接执行then回调
        case FULFILLED: {
          fulfilled(this._value)
          break
        }
        case REJECTED: {
          rejected(this._value)
          break
        }
      }
    })
  }

  catch (rejectFn) {
    return this.then(undefined, rejectFn)
  }

  finally (callback) {
    return this.then(
      value => _Promise.resolve(callback()).then(() => value),
      reason => _Promise.resolve(callback()).then(() => {throw reason}),
    )
  }

  static resolve (value) {
    return value instanceof _Promise ? value : new _Promise((resolve) => resolve(value))
  }

  static reject (reason) {
    return new _Promise((_, reject) => reject(reason))
  }

  static all (promises) {
    let count
    const res = []

    return new _Promise((resolve, reject) => {
      promises.forEach((promise, index) => {
        _Promise.resolve(promise).then(
          (value) => {
            count++
            res[index] = value
            if (count === promises.length) {
              resolve(res)
            }
          },
          (error) => {
            reject(error)
          },
        )
      })
    })
  }

  static race (promises) {
    return new _Promise((resolve, reject) => {
      for (let promise of promises) {
        _Promise.resolve(promise).then(
          (value) => {
            resolve(value)
          },
          (error) => {
            reject(error)
          },
        )
      }
    })
  }
}

new _Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(1)
  }, 500)
})
  .then(res => {
    console.log(res)
    return new _Promise((resolve) => {
      setTimeout(() => {
        resolve(2)
      }, 1000)
    })
  })
  .then(res => {
    console.log(res)
    return 3
  })
  .then(res => {
    console.log(res)
  })
  .catch(console.log)
```
+ 设计模式
    - 发布/订阅模式
    - 观察者模式
```
//发布/订阅模式
class EventEmitter {
  constructor () {
    this.events = {}
  }

  on (type, fn) {
    const typeFns = this.events[type] || (this.events[type] = [])
    typeFns.push(fn)
    return this
  }

  once (type, fn) {
    const tmpFn = (...args) => {
      fn.call(this, ...args)
      this.off(type, tmpFn)
    }
    this.on(type, tmpFn)
    return this
  }

  emit (type, ...args) {
    const typeFns = this.events[type] || []
    typeFns.forEach((fn) => fn.call(this, ...args))
    return this
  }

  off (type, fn) {
    if (fn === undefined) {
      this.events[type] = null
    }
    else {
      const typeFns = this.events[type] || []
      typeFns.splice(typeFns.indexOf(fn), 1)
    }
    return this
  }
}
//观察者模式
class Subject {
  constructor () {
    this.observers = []
  }
  add (observer) {
    this.observers.push(observer)
  }
  notify () {
    this.observers.forEach(observer => observer.update())
  }
}
class Observer {
  constructor (name) {
    this.name = name
  }
  update () {
    console.log(`目标更新: ${this.name}`)
  }
}
let sub = new Subject()
let ob = new Observer('haha')
// 添加观察者
sub.add(ob)
// 通知更新
sub.notify()
```
+ 编译原理
    - 词法分析
    - 语法解析 -> AST
    - 代码生成
+ 函数柯里化
```
function curry(fn) {
    let args = Array.prototype.slice.call(arguments, 1)
    console.log('args', args)
    return function () {
        let innerArgs = Array.prototype.slice.call(arguments)
        let finalArgs = args.concat(innerArgs)
        console.log('finalArgs', finalArgs)
        return fn.apply(null, finalArgs)
    }
}
function add(a, b) {
    return a + b
}
curry(add, 2, 3)()
```
## 综合
+ 跨域
    - jsonp
    - cors
    - postMessage
    - 代理
+ 性能优化 https://csspod.com/frontend-performance-best-practices/ https://juejin.im/post/59ff2dbe5188254dd935c8ab
    - 网络
        - 减少http请求次数
            - 合并静态资源, 雪碧图
            - 强缓存, localStorage/sessionStorage, ajax缓存
            - 小图片base64内嵌
        - 减少http请求大小
            - 压缩静态资源, gzip
            - 协商缓存
            - 减小cookie及cookie隔离
            - 压缩比更高的图片(webp)
            - 根据屏幕尺寸返回适合尺寸图片
        - 优化网络加载
            - CDN
            - HTTP2多路复用        
            - 减少重定向
            - 预加载，dns预解析
    - 渲染
        - 避免重排/重绘
            - 合并多次DOM操作
            - 合并多次样式操作
            - 先将元素display: none, 进行多次操作, 再恢复显示
            - 缓存需要重排获取到的样式属性
            - 使用离线DOM(documentFragment)
            - 绝对定位
            - 使用visibility
            - 预设图片尺寸
      - 减少js动画, 使用css动画(transform)
      - GPU加速
      - 使用requestAnimationFrame, requestIdleCallback重新渲染
      - 样式在head, 脚本在body结束前, 防止阻塞
      - 简化和优化css选择器, 减少嵌套   
    - 代码性能
      - css放头部, js放脚部
      - 避免css import
      - 阻塞渲染的css/js合理拆分延迟加载
      - 图片懒加载
      - 避免使用table/iframe
+ 首屏优化
    - 首屏css/js分割, 非首屏代码异步加载, 懒加载
    - 内联首屏css/js
    - 合理缓存: localStorage, ServiceWorker
    - SSR
    - 视觉感知优化: loading, 骨架屏, 任务异步分割
+ 网站高并发性能调优
    - 找到性能瓶颈: 程序 or 数据库, 针对性解决
    - 使用队列
    - 使用缓存: 页面缓存, redis
    - 解决阻塞: 采用异步, 合理的超时策略
    - 数据库优化: 分表分库, 建立索引, 分布式部署, 读写分离
    - 使用CDN
    - 使用负载均衡
    - 图片服务器分离: 图片耗服务器资源
    - 使用分布式集群
    - 页面静态化
+ 虚拟列表优化 https://codesandbox.io/s/virtuallist-1-rp8pi?file=/src/components/VirtualList.vue:1391-1396
+ web安全 https://juejin.im/post/5ece1cefe51d4578885c963f
    - XSS
    - CSRF
+ 打包工具
    - webpack
    - gulp
+ HTTP缓存 https://juejin.im/post/5ed48a31f265da76c26e6bfe
+ 异常监控 https://juejin.im/post/5b55c3495188251acb0cf907
    - onerror js报错
    - onunhandledrejection: Promise异常
    - XMLHttpRequest原型劫持: 网络请求异常
    - Vue异常: Vue.config.errorHandler
    - React异常: componentDidCatch
+ 性能监控
    - 页面加载: performance.getEntriesByType('navigation')
    - 资源加载: performance.getEntriesByType('resource')
```
// Frame Timing API
const observer = new PerformanceObserver(function(list) {
  const perfEntries = list.getEntries()
  for (let i = 0; i < perfEntries.length; i++) {
    console.log('FPS', perfEntries[i])
  }
})
observer.observe({entryTypes: ['frame']})

// requestAnimationFrame
let frame = 0
let lastTime = performance.now()
const timeSpan = 2000

function loop () {
  const now = performance.now()

  frame++

  if (now >= timeSpan + lastTime) {
    const fps = Math.round(frame / (now - lastTime) * 1000)
    console.log(`${Date.now()} FPS: ${fps}`)

    frame = 0
    lastTime = now
  }

  requestAnimationFrame(loop)
}

loop()
```    
+ CDN原理
    - 负载均衡
    - 动态分发和复制
    - 缓存
+ GET/POST区别
    - GET
        - 请求数据, 用于取回数
        - 可被缓存
        - 保存在浏览器历史记录中
        - 可被收藏为书签
        - 不宜处理敏感数据, 因为参数在url中明文传递
        - 上传数据长度: 限制为4KB, 类型: 只允许ASCII字符
        - 后退/刷新 无害
        - 编码类型: application/x-www-form-urlencode
    - POST
        - 用于提交数据
        - 数据可在请求主体中发送
        - 不会保存在浏览器历史记录中
        - 不能被收藏为书签
        - 上传数据长度/类型: 无限制
        - 后退/刷新 数据可能会重新提交
        - 编码类型: application/x-www-form-urlencoded, multipart/form-data, application/json等
## 移动端
+ 移动端与PC端区别
    - 屏幕尺寸
    - 操作方式: 触摸, 手势
    - 传感器: 重力感应
    - 性能: 渲染性能可能较低
    - 网速, 续航
+ 移动端布局
    - viewport
    - rem
    - 750px宽度设计稿，html font-size:13.3333333333333vw
+ 1px边框
    - transform: scale(0.5)
    - box-shadow
    - border-image
    - 0.5px
## webpack 4.0
+ 核心概念
    - entry
    - output
    - loader
    - plugins
    - chunk
+ 优化插件 
    - 
## VUE
+ vuex
    - state
    - mutations
    - actions
    - getters
    - modules
## REACT
+ 性能优化
    - 合理规划state，避免不必要的render调用
    - 重写shouldComponentUpdate避免重复渲染
    - 使用不可突变数据结构
    - props按需传递
    - 合并状态更新，避免多次渲染
    - 使用函数组件
    - 使用PureComponent
+ setState为什么是异步
    - 保持内部一致性
    - 能够使用并发更新，从而优化性能
+ VUE和REACT对比
|  不同点   |  VUE   | REACT  |
|  ----  | ----  | ----  |
| 设计思想  | html,css,js三层设计 | jsx语法, all in js |
| 响应原理  | 使用Object.defineProperty精准监听数据, 组件级别更新渲染 | 调用setState或者props变化时, 组件及所有子组件render运算, 再diff更新渲染 |
| 组件形式  | .vue单文件 | 函数/类组件 |
| 数据管理  | props, data | props, state(类组件), useState(函数组件) |
| 父子组件通信  | props, $emit | props, props传递的回调函数 |
| 跨组件通信  | provide/inject, vuex | Context, redux |
| class/style  | class,style, 支持对象/字符/数组 | className,style |
| 生命周期  | beforeCreate,created beforeMount,mounted beforeUpdate,updated beforeDestroy,destroyed | 初始化: constructor 挂载: getDerivedStateFromProps => render => componentDidMount 更新: getDerivedStateFromProps => shoudeComponentUpdate => render => getSnapshotBeforeUpdate => componentDidUpdate 卸载: componentWillUnmount |
| 事件  | @type, 修饰符, $event | onType |
| 条件渲染  | v-if指令 | &&,三目运算,多重判断 |
| 是否显示  | v-show指令 | style/className |
| 列表渲染  | v-for指令 | map |
| 计算属性  | computed | useMemo |
| 侦听器  | watch | getDerivedStateFromProps, componentDidUpdate |
| ref  | 字符 | createRef(类), useRef(函数) |
| 表单  | v-model | 受控组件/非受控组件 |
| 插槽  | slot | props.children, render props |
| 复用性  | mixins | HOC, render props |
+ 路由原理 https://juejin.im/post/5d2d19ccf265da1b7f29b05f
+ 虚拟DOM和DIFF https://juejin.im/post/5cac5a87e51d456e7618a67b
## NODEJS
+ NODEJS入门指南 https://juejin.im/post/5e0006c251882512795675f9
+ CURL用法指南 http://www.ruanyifeng.com/blog/2019/09/curl-reference.html
+ 有难度的面试题 https://juejin.im/post/5d2fc598e51d4577596487a3
