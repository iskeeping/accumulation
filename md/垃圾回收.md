## 前言

js具有自动垃圾回收机制，换句话说，执行环境会管理代码执行过程中使用的内存。

## js垃圾回收的原理

执行环境会找出那些不再继续使用的变量，然后释放其占用的内存。

## js垃圾回收的策略

### 标记清除

当变量进入环境（例如，在函数中声明变量）时，就将这个变量标记为“进入环境”，而当变量离开环境时，则将其标记为“离开环境”。

标记变量方式看具体的实现，可以使用一个“进入环境”的变量列表和一个“离开环境”的变量列表来跟踪哪个变量发生了变化。

使用过标记清除的浏览器有IE，Firefox，chrome。

### 引用计数

这是一种不太常见的垃圾回收的实现，它就是跟踪每一个值被引用的次数。

当声明了一个变量a并将一个引用类型值（{name:'cc'}）赋给该变量时，则这个值的引用次数就是1，如果a（{name:'cc'}）又赋给另一个变量b，则该值的引用次数加1。反之，如果a赋值{name:'xx'}，则{name:'cc'}这个值的引用次数减1。当{name:'cc'}这个值的引用的次数变为0时，则说明没有办法再访问{name:'cc'}这个值了，因而可以将其占用的内存空间回收。这样，当垃圾回收器工作的时候，{name:'cc'}这个值占用的内存空间就会被回收。

这种方式曾今被Netscape Navigator 3.0使用过，但是有一个严重问题：循环引用。

```
function circleUseProbem(){
  let objectA = new Object()
  let objectB = new Object()

  objectA.someOtherObject = objectB
  objectB.anotherObject = objectA
}
```

执行这个函数后，因为这两个引用值的引用次数永远不会为0，垃圾回收器永远不会回收它们占用的内存空间。

## js垃圾回收器的性能

如果为变量分配的内存数量不大的话，那么垃圾回收器的回收工作量就不大。但是，当垃圾回收器的工作量过大的时候，就会出现卡的情况。

## js中管理内存的建议

+  尽量少用全局变量
+  尽可能手动清除变量的引用

谢谢阅读！