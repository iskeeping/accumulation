## 管理

1. 如何带团队的
2. 如何带项目的

## 项目

1. 最满意的项目
2. 项目中的扮演的角色
3. 项目中的亮点
4. 一些提高效率的工作（前端日志监控，前端构建工具，ui组件库，可视化组件库，业务组件库）

## css

1. 盒子模型以及其组成
2. 如何实现水平垂直居中
3. BFC以及BFC的使用场景
4. 选择器的优先级
5. 布局的几种方式
6. 自适应布局的几种方式
7. 1px的解决方案
8. 伪类和伪元素的区别

## javascript

1. 事件循环以及使用
2. 几种数组去重方式
3. new的过程
4. instanceof的实现
5. promise以及实现
6. async/await的并发和继发
7. for in和for of的区别
8. 伪数组和数组的区别
9. call、apply、bind的区别
10. let、const和var的区别
11. es modules和common js的区别
12. 箭头函数和普通函数的区别
13. 防抖和节流的区别以及实现
14. weakMap、weakSet的使用场景
15. 内存泄漏以及内存泄漏的场景
16. 新老生代的垃圾回收
17. es6和es5的继承
18. 原型和原型链
19. 作用域和作用域链
20. 数据类型和内存管理
21. 闭包和闭包的使用场景
22. 柯里化函数和偏函数
23. 事件机制和事件委托
24. 点透以及解决方案
25. ServiceWorker
26. h5和app的通信原理
27. 深拷贝和浅拷贝的区别以及实现
28. 宏任务和微任务区别以及优先级

## vue

1. 组件的通信方式
2. keep-alive的原理
3. 指令和指令的应用
4. vuex以及其使用
5. 插槽和插槽的作用域
6. 如何实现v-model
7. v-for中key的作用
8. vdom以及相关的库
9. diff算法
10. 数据响应式原理
11. computed和watch的区别
12. v-if和v-show的区别
13. 组件的全局和局部注册
14. mutation和action的区别
15. 组件data为何是函数
16. $route.params和$route.query的区别
17. vue的生命周期
18. vue如何监听数组变化
19. vue3.0的proxy
20. 如何模拟react的高阶组件
21. vue为什么是异步渲染
22. 为什么使用vdom
23. 自定义组件v-model的使用

## react

1. 生命周期
2. react事件和dom事件的区别
3. 组件的通信方式
4. redux
5. mobx
6. shouldComponentUpdate
7. vue和react的对比
8. vue和react的diff算法的区别

## webpack和babel

1. webpack的性能优化
2. loader和plugin的区别
3. tree-shaking
4. 常用的loader的作用
5. 什么是babel-polyfill
6. 什么是babel-runtime
7. 什么是presets和plugins
8. chunk是什么
9. 使用过的plugin的原理，例如happypack等

## 小程序

1. 小程序最新的版本更新了什么内容
2. 小程序的渲染原理

## 浏览器

1. 从输入URL到页面渲染成画面的过程
2. 浏览器缓存
3. 浏览器跨域

## 优化

1. 网页性能优化
2. 首屏计算
3. 首屏优化
4. 长列表优化
5. 接口耗时10s，如何在前端做优化

## 抽象语法树

1. es6源代码到es5的过程中发生了什么

## http(s)

1. http的强缓存和协商缓存
2. https和http的区别
3. http2.0的新特性

## web安全

1. xss
2. csrf

## 设计模式

1. 自定义一个事件发射器

## 前端趋势

1. TypeScript
2. WebAssembly
3. Flutter、React Native、uni-app/Taro
4. 微前端
5. deno
6. vue3.0
